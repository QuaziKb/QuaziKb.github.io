<html>
<head>
	<link rel="stylesheet" type="text/css" href="../index.css">
	<META name="keywords" content="verlet physics"> 
	<title>Verlet</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function () {	
  // Hide MathJax until rendered by putting them in divs of the class "hide_math"
	var mathdivs = document.getElementsByClassName("hide_math");
	for (i = 0; i < mathdivs.length; i++) { 
		mathdivs[i].style.visibility = "";
	}	
  });
</script>
<script type="text/javascript" src="../js/MathJax/MathJax.js?config=TeX-AMS_HTML-full"></script>
<script src="../js/QZMath.js"></script>
<script src="../js/three.js"></script>
<script src="../js/OrbitControls.js"></script>	
</head>

<body>
<div id="wrap">

<h1>Verlet Physics</h1>
<br>
Real time physics simulation is <b>hard</b> to get right. Numerical simulation, equations of motion, collision detection, and constraint solving are all very complex interrelated topics. Getting simulations to work takes a lot of effort.
<br>
<br>
Verlet integration, or related methods like position based dynamics, are nice ideas because they simplify the work involved with physics simulation considerably. They introduce their own limitations and their own way of thinking, but generally for physical systems involving "spheres" (really point masses because they have no rotational inertia), constraints, and static geometry, they're very stable and very fast. Collision detection and resolution is easy when everything is a sphere or signed distance field, and constraint resolution is intuitive since it involves moving things into legal positions using projection rather than solving for forces.
<br>
<br>
Below is a little interactive toy I made using verlet integration. I like to apply verlet integration a lot in games because the implementation is so simple and the code runs really fast. You can make 1D, 2D, and 3D systems (N dimensional works too but good luck visualizing it) with essentially the same techniques, and get nice physically based systems. The simulations are stable and adding constraints on the movement is easy. You can make "hacky" physics that runs really fast, looks just as good as real rigid body physics in most cases. This is really nice for secondary motion, since you can have real physics moving objects around reactively without needing to have the overhead of a fully featured physics engine.
<br>
<br>
<script src="js/main.js"></script>
<br>
<div id="cent_text">
<i><b>figure 1</b> : verlet physics softbody using shape matching</i>
</div>
<br>
<hr>
<h2>Site Navigation</h2>
<a href="../index.html">Homepage</a>
	<br>
	<br>
	<hr>
<div id="copyright_text">
&copy; 2018 Kevin Bergamin.
</div>
</div>

</BODY>
</HTML>
